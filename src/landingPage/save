import React from "react";
import {
  Button,
  Grid,
  Icon,
  Header,
  Image,
  Label,
  Segment
} from "semantic-ui-react";
import { thisExpression } from "@babel/types";
import LandingPage from "./LandingPage";
import LandingPageButton from "./LandingPageButton";
import CreateButton from "./CreateButton";
import ImportButton from "./ImportButton";

const ruleTypes = {
  hasAccessRules: {
    conclusion: "hasAccess",
    defaultValue: false
  },
  hasObstacleRules: {
    conclusion: "isObstacle",
    defaultValue: true
  },
  hasOnewayRules: {
    conclusion: "isOneway",
    defaultValue: true
  },
  hasPriorityRules: {
    conclusion: "isReversed",
    defaultValue: 0
  },
  hasSpeedRules: {
    conclusion: "hasSpeed",
    defaultValue: 35
  }
};

class Index extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      screen: "welcoming",
      errorMessage: "",
      configFile: "",
      file: ""
    };
    this.triggerImportFile = this.triggerImportFile.bind(this);
    this.validFileScreen = this.validFileScreen.bind(this);
    this.errorScreen = this.errorScreen.bind(this);
  }

  parseConfigurationFile = () => {};

  triggerImportFile(reactComponent) {
    var array = document.getElementsByClassName("import_file_button");
    if (array.length != 1) return;

    var fileInput = array[0];
    fileInput.click();
    fileInput.addEventListener("change", function(e) {
      var file = fileInput.files[0];
      var textType = /json.*/;

      if (file.type.match(textType)) {
        console.log("good extension");
        var reader = new FileReader();

        reader.onload = function(e) {
          var configFile;
          try {
            reactComponent.setState({
              screen: "valid_file",
              configFile: JSON.parse(reader.result),
              file: file
            });
          } catch (error) {
            reactComponent.setState({
              screen: "invalid_file",
              errorMessage: "File badly formated"
            });
          }
        };

        reader.readAsText(file);
      } else {
        console.log("not good extension");
        reactComponent.setState({ screen: "unvalid_file" });
      }
    });
  }
  computeNumberOfRules() {
    var nbOfRules = 0;

    if (this.state.configFile === undefined) return nbOfRules;
    Object.keys(ruleTypes).map(k => {
      nbOfRules += this.state.configFile[k].length;
    });

    return nbOfRules;
  }

  validFileScreen() {
    return (
      <div>
        <Header> {this.state.file.name} </Header>
        <Segment>
          {" "}
          <Label> Label: </Label> {this.state.configFile["rdfs:label"]}{" "}
        </Segment>
        <Segment>
          {" "}
          <Label> Number of rules: </Label> {this.computeNumberOfRules()}
        </Segment>
      </div>
    );
  }

  errorScreen() {
    return (
      <Header>
        {" "}
        <Header.Content>{this.state.errorMessage}</Header.Content>
      </Header>
    );
  }

  render() {
    return (
      <Grid centered>
        <Grid.Row columns={1} stretched style={{ height: "80%", padding: "0" }}>
          <Grid.Column className="contentColumn">
            <div>
              <Header as="h2" icon textAlign="center">
                <Image
                  centered
                  rounded
                  src="assets/logo.jpg"
                  className="centerLogo"
                />
                <Header.Content>
                  Your go-to for creating robust route configurations
                </Header.Content>
              </Header>
              <Header as="h3" dividing textAlign="center">
                Purpose
              </Header>
              <p>
                Ever traveled with unconventional means of transport such as a
                scooter ? You want to reach specific locations but your route
                planner takes you through uncomfortable routes? We believe your
                journey should always be adapted to your very specific mobility
                needs. For this reason, we created *ConfiguRoute* : a tool to
                quickly and easily create finely tuned configuration files for
                your transport profiles. These configs can then be used to
                design existing or new route planners.
              </p>
            </div>
          </Grid.Column>
        </Grid.Row>
        <Grid.Row columns={2} stretched style={{ height: "20%", padding: "0" }}>
          <Button.Group style={{ width: "100%" }}>
            <CreateButton />
            <Button.Or />
            <ImportButton
              onClick={() => {
                this.triggerImportFile(this);
                console.log("wtfff");
              }}
            />
          </Button.Group>
        </Grid.Row>
      </Grid>
    );
  }
}

export default Index;
